title: Dictionary

# Python работа со словорями

## Определение и удобство словаря
!!! note "Словарь являются изменяемым типом данных"

```bash
Определение: словарь состоит из выражения в фигурных скобках 
пар ключ-значение 
{'ключ1': 'значение1','ключ2': 'значение2'}
Удобство в том, что значение элемента словаря это не индекс, а имя
```

```bash
#Справнение словаря со списком
# Создадим список
In [449]: list1 = ['R1','1.1.1.1','15.1']

#К элементам списка можно обращаться только по индексу
In [450]: list1[0]
Out[450]: 'R1'

In [451]: list1[2]
Out[451]: '15.1'


#Создадим словарь
In [453]: dict1 = {'hostname': 'R1',
     ...:         'lo0': '1.1.1.1',
     ...:         'ver': '15.1'}

#К элементам словаря можно обращаться по имени
In [455]: dict1['lo0']
Out[455]: '1.1.1.1'

In [456]: dict1['ver']
Out[456]: '15.1'
```

## Добавление данных в словарь

```bash
In [459]: dict1['vlan'] = '10'

In [460]: dict1
Out[460]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1', 'vlan': '10'}


In [462]: dict1['vlan']
Out[462]: '10'
```

## Изменение данных в словаре

Перезапись данных в словаре

```bash
In [467]: dict1['vlan']=11

In [468]: dict1
Out[468]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1', 'vlan': 11}

In [469]: dict1['vlan']
Out[469]: 11
```

## Удаление данных из словаря del

```bash
# Через опреатор del
In [472]: del dict1['lo0']

In [473]: dict1
Out[473]: {'hostname': 'R1', 'ver': '15.1', 'vlan': 11}

```

## Словарь словарей
```bash
In [484]: krk_filial = {
     ...: 'router1' : {'hostname': 'R1', 'ver': '15.1', 'vlan': 11, 'lo1': '1.1.1.1'},
     ...: 'router2' : {'hostname': 'R2', 'ver': '15.2', 'vlan': 12, 'lo2': '2.2.2.2'},
     ...: 'router3' : {'hostname': 'R3', 'ver': '15.3', 'vlan': 13, 'lo3': '3.3.3.3'}
     ...: }

In [485]: krk_filial
Out[485]:
{'router1': {'hostname': 'R1', 'ver': '15.1', 'vlan': 11, 'lo1': '1.1.1.1'},
 'router2': {'hostname': 'R2', 'ver': '15.2', 'vlan': 12, 'lo2': '2.2.2.2'},
 'router3': {'hostname': 'R3', 'ver': '15.3', 'vlan': 13, 'lo3': '3.3.3.3'}}


In [486]: krk_filial['router1']
Out[486]: {'hostname': 'R1', 'ver': '15.1', 'vlan': 11, 'lo1': '1.1.1.1'}

In [487]: krk_filial['router1']['hostname']
Out[487]: 'R1'

```
## Методы работы со словарем
Все те свойства, что и у списков свойственно и словарям

### Присваивание
```bash
 [484]: krk_filial = {
     ...:'router1' : {'hostname': 'R1', 'ver': '15.1', 'vlan': 11, 'lo1': '1.1.1.1'},
     ...:'router2' : {'hostname': 'R2', 'ver': '15.2', 'vlan': 12, 'lo2': '2.2.2.2'},
     ...:'router3' : {'hostname': 'R3', 'ver': '15.3', 'vlan': 13, 'lo3': '3.3.3.3'}
     ...: }

     In [485]: krk_filial
	Out[485]:
	{'router1': {'hostname': 'R1', 'ver': '15.1', 'vlan': 11, 'lo1': '1.1.1.1'},
	 'router2': {'hostname': 'R2', 'ver': '15.2', 'vlan': 12, 'lo2': '2.2.2.2'},
	 'router3': {'hostname': 'R3', 'ver': '15.3', 'vlan': 13, 'lo3': '3.3.3.3'}}

# При присваивании словарей они оба ссылаются на оду и ту же область памяти

In [493]: orion_filial = krk_filial

In [494]: id(krk_filial)
Out[494]: 140236435968072

In [495]: id(orion_filial)
Out[495]: 140236435968072

# Соответственно изменение в одном словаре ведет к изменению в другом
In [500]: krk_filial['router1']['hostname']='R10'


In [501]: krk_filial['router1']['hostname']
Out[501]: 'R10'

In [502]: orion_filial['router1']['hostname']
Out[502]: 'R10'


In [504]: krk_filial['router1']
Out[504]: {'hostname': 'R10', 'ver': '15.1', 'vlan': 11, 'lo1': '1.1.1.1'}

In [503]: orion_filial['router1']
Out[503]: {'hostname': 'R10', 'ver': '15.1', 'vlan': 11, 'lo1': '1.1.1.1'}
```

### Создании копии

!!! warning "copy() работает только для одинарных словарей. Для вложенных второй и далее уровни идут ссылками, т.е. id будет одно и тоже. Подробнее будет рассмотрено позже"
```bash

In [511]: dict1 = {'hostname': 'R1',
     ...:         'lo0': '1.1.1.1',
     ...:         'ver': '15.1'}

In [512]: dict1
Out[512]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1'}


In [513]: dict2 = dict1.copy()


In [514]: dict1
Out[514]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1'}

In [515]: dict2
Out[515]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1'}

In [516]: dict2['hostname']='R10'

In [517]: dict1
Out[517]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1'}

In [518]: dict2
Out[518]: {'hostname': 'R10', 'lo0': '1.1.1.1', 'ver': '15.1'}
```
### Удаление содержимого
```bash

In [519]: dict1
Out[519]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1'}

In [520]: dict1.clear()

In [521]: dict1
Out[521]: {}
```

### проверка наличия ключа в словаре (пр отсутствие ключа возвращает "None")
```bash
In [523]: dict1
Out[523]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1'}


In [524]: dict1.get('location')

In [525]: print(dict1.get('location'))
None

In [526]: dict1.get('hostname')
Out[526]: 'R1'

# удобно задачть возвращаемое значание при отсутствии ключа
# можно по нему чекать в условиях типа if

# ключа 'locaion' - нет, п.э. выдастся в кач-ве результата цифра 10
In [527]: print(dict1.get('location',10))
10

# ключа 'hostname' - неn, то выдастся в кач-ве результата цифра 10
# если ключ 'hostname' есть, то вернется его значение как в данном случае 'R1'
In [528]: dict1.get('hostname',10)
Out[528]: 'R1'

```
### Метод setdefault

"Хитрый" метод, который возващает значение по ключу если ключ есть,
устанавливает значение "None" - если нет ключа и в явном виде не задано значение в методе,
устанавливает значение, которое указано в параметре - если нет ключа и в явном виде задано значение в методе

```bash
In [523]: dict1
Out[523]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1'}

#возващает значение по ключу если ключ есть
In [529]: dict1.setdefault('hostname')
Out[529]: 'R1'

# Устанавливает значение "None" - если нет ключа 
# и в явном виде не задано значение в методе

In [530]: dict1.setdefault('location')

In [531]: dict1
Out[531]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1', 'location': None}

# Устанавливает значение, которое указано в параметре - если нет ключа 
# и в явном виде задано значение в методе
# пример для значение типа integer
In [534]: dict1.setdefault('location1',10)
Out[534]: 10

In [535]: dict1
Out[535]:
{'hostname': 'R1',
 'lo0': '1.1.1.1',
 'ver': '15.1',
 'location': None,
 'location1': 10}

# Устанавливает значение, которое указано в параметре - если нет ключа 
# и в явном виде задано значение в методе
# пример для значение типа string
In [536]: dict1.setdefault('loaction2','10')
Out[536]: '10'

In [537]: dict1
Out[537]:
{'hostname': 'R1',
 'lo0': '1.1.1.1',
 'ver': '15.1',
 'loaction': None,
 'loaction1': 10,
 'loaction2': '10'}

# Надеюсь стало понятнее )
```

### Показать все ключи словаря keys()
```bash
In [542]: dict1.keys()
Out[542]: dict_keys(['hostname', 'lo0', 'ver', 'loaction', 'loaction1', 'loaction2'])
```

### Показать все значения словаря keys()
```bash
In [543]: dict1.values()
Out[543]: dict_values(['R1', '1.1.1.1', '15.1', None, 10, '10'])
```

### Показать пары ключ-значение словаря items()
```bash

In [544]: dict1.items()
Out[544]: dict_items([('hostname', 'R1'), ('lo0', '1.1.1.1'), ('ver', '15.1'), ('loaction', None), ('loaction1', 10), ('loaction2', '10')])
```

### Добавление данных в словарь из другого update()
Примечание: Значение дублировованных ключей переписываются новыми
```bash


In [546]: dict1 = {'hostname': 'R1',
     ...:         'lo0': '1.1.1.1',
     ...:         'ver': '15.1'}

In [547]: dict2 = {'vendor': 'cisco',
     ...:         'lo0': '2.2.2.2',
     ...:         'mail': 'tac@mail.com'}

In [548]: dict1
Out[548]: {'hostname': 'R1', 'lo0': '1.1.1.1', 'ver': '15.1'}

In [549]: dict2
Out[549]: {'vendor': 'cisco', 'lo0': '2.2.2.2', 'mail': 'tac@mail.com'}

In [550]: dict1.update(dict2)

In [551]: dict1
Out[551]:
{'hostname': 'R1',
 'lo0': '2.2.2.2',
 'ver': '15.1',
 'vendor': 'cisco',
 'mail': 'tac@mail.com'}

In [552]: dict2
Out[552]: {'vendor': 'cisco', 'lo0': '2.2.2.2', 'mail': 'tac@mail.com'}

```

### Создание словаря чз функцию dict 
```bash
In [560]: dict3 = dict(vendor='cisco', ver =15.1, lo0='2.2.2.2',mail='tac@mail.com')

In [561]: dict3
Out[561]: {'vendor': 'cisco', 'ver': 15.1, 'lo0': '2.2.2.2', 'mail': 'tac@mail.com'}

```

### Создание пустого словаря из списка ключей
```bash
In [562]: d_key = ['vendor', 'ver', 'lo0',  'mail']

In [563]: dict.fromkeys(d_key)
Out[563]: {'vendor': None, 'ver': None, 'lo0': None, 'mail': None}
```

### Создание  словаря из списка ключей, где каждый ключ это список
! warning "Чтобы значение ключей были уникальными на пракике используется  генератор словарей"

```bash
# задаем значение ключей
In [567]: d_key = ['vendor', 'ver', 'lo0',  'mail']

# создаем словарь
In [568]: dict1  = dict.fromkeys(d_key,[])

In [571]: dict1
Out[571]: {'vendor': 'cisco', 'ver': [], 'lo0': [], 'mail': []}

# для ключа vendor добавляем значение 
In [577]: dict1['vendor'].append('cisco')

# на самом деле все значения словаря ссылаются при создании 
# на один и тот же список, п.э для свех меняется значение
In [578]: dict1
Out[578]: {'vendor': ['cisco'], 'ver': ['cisco'], 'lo0': ['cisco'], 'mail': ['cisco']}

# чтобы этого не происходило используем генератор словарей
In [579]: d_key = ['vendor', 'ver', 'lo0',  'mail']

#генератор словарей
# при такой генерации каждый ключ ссылается на отдельный список
In [580]: dict1  = {key: [] for key in d_key}

# и тогда метод append будет работать правильно, 
# т.к. будет заполняеться индивидуальный список для каждого ключа
In [581]: dict1
Out[581]: {'vendor': [], 'ver': [], 'lo0': [], 'mail': []}

In [582]: dict1['vendor'].append('cisco')

In [583]: dict1
Out[583]: {'vendor': ['cisco'], 'ver': [], 'lo0': [], 'mail': []}
```