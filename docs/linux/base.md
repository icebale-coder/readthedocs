title: Linux bases

# Linux базовые понятия

## 1. Последовательность запуска системы.

### 1.2. Последовательность загрузки/загрузчик grub

### 1.3 Системы скриптов init.d/systemctl

## 2. Сигналы POSIX

- [Citforum Программирование для Linux", журнал Linux Format](http://citforum.ru/programming/unix/signals/)

Сигналы в Linux - это одно средство взаимодействия между процессами.
Главное отличие от других средств взаимодействия между процессами заключается в том, что их обработка программой происходит сразу же после их поступления.
Сигнал прерывает нормальный порядок выполнения инструкций в программе и передает управление специальной функции – обработчику сигнала.

Сигналы:
```bash
"SIGHUP (номер 1)" изначально был предназначен для того, 
чтобы информировать программу о потере связи с управляющим терминалом 
(терминалы часто подключались к системе с помощью модемов, так что название сигнала происходит от hung up – повесить трубку). 
Сигнал SIGHUP посылается приложению так же и в том случае, если процесс-лидер сессии завершил свою работу. 
Многие программы-демоны, у которых нет лидера сессии, так же обрабатывают этот сигнал. 
В ответ на получение SIGHUP демон обычно перезапускается (или просто повторно читает файл конфигурации). 
По умолчанию программа, получившая этот сигнал, завершается.

"SIGINT (номер 2)" обычно посылается процессу, 
если пользователь терминала дал команду прервать процесс (обычно эта команда – сочетание клавиш Ctrl-C) .

"SIGABRT (номер 6)" посылается программе в результате вызова функции abort(3). 
В результате программа завершается с сохранением на диске образа памяти.

"SIGKILL (номер 9)" завершает работу программы. 
Программа не может ни обработать, ни игнорировать этот сигнал.

"SIGSEGV (номер 11)" посылается процессу, который пытается обратиться к не принадлежащей ему области памяти. 
Если обработчик сигнала не установлен, программа завершается с сохранением на диске образа памяти.

"SIGTERM (номер 15)" вызывает «вежливое» завершение программы. 
Получив этот сигнал, программа может выполнить необходимые перед завершением операции (например, высвободить занятые ресурсы). 
Получение SIGTERM свидетельствует не об ошибке в программе, а о желании ОС или пользователя завершить ее.

"SIGCHLD (номер 17)" посылается процессу в том случае, если его дочерний процесс завершился или был приостановлен. 
Родительский процесс также получит этот сигнал, если он установил режим отслеживания сигналов дочернего процесса 
и дочерний процесс получил какой-либо сигнал. 
По умолчанию сигнал SIGCHLD игнорируется.

"SIGCONT (номер 18)" возобновляет выполнение процесса, остановленного сигналом SIGSTOP.

"SIGSTOP (номер 19)" приостанавливает выполнение процесса. 
Как и SIGKILL, этот сигнал не возможно перехватить или игнорировать.

"SIGTSTP (номер 20)" приостанавливает процесс по команде пользователя (обычно эта команда – сочетание клавиш Ctrl-Z).

"SIGIO/SIGPOLL (в Linux обе константы обозначают один сигнал – номер 29)" сообщает процессу, что на одном из дескрипторов, 
открытых асинхронно, появились данные. По умолчанию этот сигнал, как ни странно, завершает работу программы.
```

### Программа для работы с сигналами в Unix
```bash
"kill"
формат

kill -s <signal> pid
kill -<signal> pid
```
- [apache Останов и перезапуск](https://uneex.ru/static/Apache_2.0_Doc/stopping.html)

<details><summary>Пример для httpd</summary>
<p>

```bash
# поиск pid основного процесса https
# номер основного процесса тут 7877 
ps -ef | grep http
apache    4068  7877  0 Aug13 ?        00:00:04 /usr/sbin/httpd
root      7877     1  0 Jul22 ?        00:00:00 /usr/sbin/httpd
apache   12414  7877  0 00:23 ?        00:00:00 /usr/sbin/httpd
root     13183 12296  0 00:24 pts/1    00:00:00 grep http
apache   15995  7877  0 Aug13 ?        00:00:02 /usr/sbin/httpd
apache   19306  7877  0 Aug14 ?        00:00:00 /usr/sbin/httpd
apache   22057  7877  0 Aug13 ?        00:00:03 /usr/sbin/httpd
apache   25024  7877  0 Aug14 ?        00:00:02 /usr/sbin/httpd

# команда -k graceful - посылает сигнал SIGHUP, по которому "мягко перезапускается httpd
apachectl -k graceful

# по факту основной процесс остался 7877, а дочернии все обновились
ps -ef | grep http
root      7877     1  0 Jul22 ?        00:00:00 /usr/sbin/httpd
apache   14236  7877  0 00:25 ?        00:00:00 /usr/sbin/httpd
apache   14237  7877  0 00:25 ?        00:00:00 /usr/sbin/httpd
apache   14238  7877  0 00:25 ?        00:00:00 /usr/sbin/httpd
apache   14239  7877  0 00:25 ?        00:00:00 /usr/sbin/httpd
apache   14240  7877  0 00:25 ?        00:00:00 /usr/sbin/httpd
apache   14241  7877  0 00:25 ?        00:00:00 /usr/sbin/httpd
apache   14265  7877  0 00:25 ?        00:00:00 /usr/sbin/httpd
apache   14266  7877  0 00:25 ?        00:00:00 /usr/sbin/httpd
root     14269 12296  0 00:25 pts/1    00:00:00 grep http

# через команду kill посылает сигнал SIGHUP, по которому "мягко перезапускается httpd
kill -SIGHUP 7877

# по факту основной процесс остался 7877, а дочернии все обновились
ps -ef | grep http
root      7877     1  0 Jul22 ?        00:00:00 /usr/sbin/httpd
apache   14683  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   14684  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   14685  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   14686  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   14687  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   14688  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   14689  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   14690  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
root     14741 12296  0 00:26 pts/1    00:00:00 grep http

# через команду kill посылает сигнал SIGHUP, но уже чз цифровой параметр, по которому "мягко перезапускается httpd
kill -1 7877

# по факту основной процесс остался 7877, а дочернии все обновились
ps -ef | grep http
root      7877     1  0 Jul22 ?        00:00:00 /usr/sbin/httpd
apache   15154  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   15155  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   15156  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   15157  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   15158  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   15159  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   15160  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
apache   15161  7877  0 00:26 ?        00:00:00 /usr/sbin/httpd
root     15195 12296  0 00:26 pts/1    00:00:00 grep http

# через команду kill посылает сигнал SIGTERM, но уже чз цифровой параметр, по которому httpd завершается
kill -15 7877

# как видим нет процесса httpd 
ps -ef | grep http
root     15947 12296  0 00:27 pts/1    00:00:00 grep http

# стартуем сервис httpd заново
service httpd start
Starting httpd:                                            [  OK  ]

# как видим сервис http запустился вместе с дочерними процессами
ps -ef | grep http
root     16845     1  0 00:28 ?        00:00:00 /usr/sbin/httpd
apache   16847 16845  0 00:28 ?        00:00:00 /usr/sbin/httpd
apache   16848 16845  0 00:28 ?        00:00:00 /usr/sbin/httpd
apache   16849 16845  0 00:28 ?        00:00:00 /usr/sbin/httpd
apache   16850 16845  0 00:28 ?        00:00:00 /usr/sbin/httpd
apache   16851 16845  0 00:28 ?        00:00:00 /usr/sbin/httpd
apache   16852 16845  0 00:28 ?        00:00:00 /usr/sbin/httpd
apache   16853 16845  0 00:28 ?        00:00:00 /usr/sbin/httpd
apache   16854 16845  0 00:28 ?        00:00:00 /usr/sbin/httpd
root     16896 12296  0 00:29 pts/1    00:00:00 grep http

```
</p>
</details>


## 3. Файловая система

### 3.1.  Типы файлов

- [Виды файлов в Linux: «всё есть файл»](https://otus.ru/nest/post/1285/)

!!!warning "Важно"
			Один из основных Unix консептов - что "всё есть файл"...

Основываясь на этом универсальном консепте рассмотрю основные виды файлов в Unix.
Преимущество такой концепции заключается в том, что отпадает необходимость в реализации отдельного набора API для каждого устройства, 
в результате чего с ним способны работать все стандартные программы.

```bash
Основные типы файлов Unix:
1. "обыкновенные" (для хранения информации)
2. "специальные" (для туннелей и устройств)
3. "директории"
```

#### 3.1.1 "обыкновенные" (для хранения информации)
```bash
1. "обыкновенные" (для хранения информации):
- "текстовые файлы"
- "файлы изображений, архивов, библиотек"
- "исполняемые"

Обыкновенные файлы в ls начинаются с "-" - в REG-EXP это соответственно "^-" 
Пример обыкновенных файлов:
ls -la /var/log | grep "^-"
-rw-r--r--  1 root root      280 Aug 13 06:25 alternatives.log
-rw-r--r--  1 root root     3771 Aug 12 03:26 alternatives.log.1
-rw-r--r--  1 root root      154 Jul  2 00:01 alternatives.log.2.gz
-rw-r--r--  1 root root     1759 Feb 23 06:56 alternatives.log.3.gz
-rw-r-----  1 root adm    377256 Aug 15 03:17 auth.log
-rw-r-----  1 root adm   5298283 Aug 15 00:00 auth.log.1
-rw-r-----  1 root adm   1501004 Aug  8 00:00 auth.log.2.gz
-rw-r-----  1 root adm   1377849 Aug  1 00:00 auth.log.3.gz
-rw-r-----  1 root adm   1568911 Jul 25 00:00 auth.log.4.gz
---cut---

Пример типа обыкновенного файла.
file /var/log/alternatives.log
/var/log/alternatives.log: ASCII text

Однако для исполняиемых и пр. будет другим: 
file /usr/lib/libdiscover.so.2.0.1
/usr/lib/libdiscover.so.2.0.1: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),
dynamically linked, BuildID[sha1]=dc4cfc96cd4585890abc0d6014eb40550149a0ee, stripped

```

#### 3.1.2. "специальные" (для туннелей и устройств)

```bash
Файлы этого типа обеспечивают обмен информацией с ядром, 
работу с устройствами либо общение между утилитами. 

С учётом своего назначения они делятся на несколько видов:
```

##### Блочные
```bash
"блочные" - файлы устройств, обеспечивающие буферный доступ к аппаратным компонентам. 
В процессе записи информации на жёсткий диск либо съёмный носитель 
данные не записываются сразу — это нерационально с точки зрения расходования ресурсов. 
Поэтому данные сначала собираются в буфере, для чего и используются блочные файлы. 
Они способны передавать большие блоки информации за один раз, 
и с их помощью файловая система и прочие утилиты получают 
возможность взаимодействовать с драйверами аппаратных устройств. 

Блочные файлы в ls начинаются с "b" - в REG-EXP это соответственно "^b" 
Пример блочных файлов:
ls -la /dev | grep "^b"
brw-rw----  1 root disk    254,   0 Jul 30 10:03 dm-0
brw-rw----  1 root disk    254,   1 Jul 30 10:03 dm-1
brw-rw----  1 root disk      8,   0 Jul 30 10:03 sda
brw-rw----  1 root disk      8,   1 Jul 30 10:03 sda1
brw-rw----  1 root disk      8,   2 Jul 30 10:03 sda2
brw-rw----  1 root disk      8,   5 Jul 30 10:03 sda5
---cut---

Пример типа блочного файла:
file /dev/sda
/dev/sda: block special (8/0)
```

##### Символьные
```bash
"Символьные" - c их помощью обеспечивается небуферизованный доступ к ядру и аппаратным компонентам. 
Это значит, что они могут передавать за раз лишь один символ. В остальном, это те же файлы устройств.

Блочные файлы в ls начинаются с "c" - в REG-EXP это соответственно "^c" 
Пример символьных файлов:
root@icebale-home:/var/run/dbus# ls -la /dev | grep "^c"
crw-r--r--  1 root root     10, 235 Jul 30 10:03 autofs
crw-------  1 root root     10, 234 Jul 30 10:03 btrfs-control
crw-------  1 root root      5,   1 Jul 30 10:03 console
crw-------  1 root root     10,  62 Jul 30 10:03 cpu_dma_latency
crw-------  1 root root     10, 203 Jul 30 10:03 cuse
crw-rw-rw-  1 root root      1,   7 Jul 30 10:03 full
crw-rw-rw-  1 root root     10, 229 Jul 30 10:03 fuse
crw-------  1 root root     10, 228 Jul 30 10:03 hpet
crw-------  1 root root     10, 183 Jul 30 10:03 hwrng
---cut---

Пример типа символьного файла:
file /dev/autofs
/dev/autofs: character special (10/235)
```

##### Символические ссылки
```bash
"Символические ссылки" - указывают на другие файлы по их имени, способны указывать и на обыкновенные файлы, 
и на каталоги, и на другие файловые типы. Обозначаются буквой l (link)

Файлы символических ссылок в ls начинаются с "l" - в REG-EXP это соответственно "^l" 
Пример символических ссылок:
ls -la /dev | grep "^l"
lrwxrwxrwx  1 root root          11 Jul 30 10:03 core -> /proc/kcore
lrwxrwxrwx  1 root root          13 Jul 30 10:03 fd -> /proc/self/fd
lrwxrwxrwx  1 root root          12 Jul 30 10:03 initctl -> /run/initctl
lrwxrwxrwx  1 root root          28 Jul 30 10:03 log -> /run/systemd/journal/dev-log
lrwxrwxrwx  1 root root           4 Jul 30 10:03 rtc -> rtc0
lrwxrwxrwx  1 root root          15 Jul 30 10:03 stderr -> /proc/self/fd/2
lrwxrwxrwx  1 root root          15 Jul 30 10:03 stdin -> /proc/self/fd/0
lrwxrwxrwx  1 root root          15 Jul 30 10:03 stdout -> /proc/self/fd/1

Пример типа файла символических ссылок:
file /dev/core
/dev/core: symbolic link to /proc/kcore
```

##### Туннели/именованные туннели
```bash
"Туннели/именованные туннели" - обеспечивают настройку связи между 2-мя процессами в системе, 
перенаправляя вывод одного на вход другого. 
Туннели именованного типа тоже применяются для связи между 2-мя процессами и функционируют, 
как и обыкновенные туннели.

Файлы туннелей в ls начинаются с "p" - в REG-EXP это соответственно "^p" 
Пример туннеля:
ls -la  | grep "^p"
prw-r--r--  1 root    root       0 Aug 15 04:21 pipe1

Пример типа файла туннеля:
file ./pipe1
./pipe1: fifo (named pipe)
```
##### Сокеты
```bash
"Cокеты" - создают прямую связь между процессами в системе. 
Передают данные между процессами, которые запущены в различных средах либо даже на различных машинах. 
Посредством сокетов программы могут осуществлять обмен информацией даже по сети. 
Работа сокета похожа на работу туннеля, но в обе стороны. 

Файлы сокетов в ls начинаются с "s" - в REG-EXP это соответственно "^s"
Пример сокета:
ls -la /var/run/dbus/ | grep "^s"
srw-rw-rw-  1 root root   0 Jul 30 10:03 system_bus_socket

Пример типа файла сокета:
file /var/run/dbus/system_bus_socket
/var/run/dbus/system_bus_socket: socket
```

#### 3.1.3 Директории

```bash
"Директории" - объединяют файлы (а также другие директории) в группы, чтобы упростить навигацию и поиск. 
В системах Unix файлы организовываются в директории, начиная от корня (/).

Директории, а точнее, "файлы директории" (звучит странно, не правда ли...) 
в ls начинаются с "d" - в REG-EXP это соответственно "^d"

Пример директорий:
ls -la /dev | grep "^d"
drwxr-xr-x 19 root root        3160 Aug 14 00:37 .
drwxr-xr-x 18 root root        4096 Jun 23 03:01 ..
drwxr-xr-x  2 root root         160 Jul 30 10:03 block
drwxr-xr-x  2 root root          60 Jul 30 10:03 bsg
drwxr-xr-x  3 root root          60 Jul 30 10:03 bus
drwxr-xr-x  2 root root        3080 Jul 30 10:03 char
drwxr-xr-x  2 root root          60 Jul 30 10:03 cpu
drwxr-xr-x  6 root root         120 Jul 30 10:03 disk
drwxr-xr-x  3 root root         100 Jul 30 10:03 dri
drwxr-xr-x  2 root root           0 Jul 30 10:03 hugepages
drwxr-xr-x  2 root root          80 Jul 30 10:03 icebale-vg
drwxr-xr-x  3 root root         320 Jul 30 10:03 input
drwxr-xr-x  2 root root         100 Jul 30 10:03 mapper
drwxrwxrwt  2 root root          40 Jul 30 10:03 mqueue
drwxr-xr-x  2 root root          60 Jul 30 10:03 net
drwxr-xr-x  2 root root           0 Jul 30 10:03 pts
drwxrwxrwt  2 root root          40 Jul 30 10:03 shm
drwxr-xr-x  3 root root         380 Jul 30 10:03 snd
drwxr-xr-x  2 root root          60 Jul 30 10:03 vfio

Пример типа файла директория:
file /dev/block
/dev/block: directory
```


### 3.2.Права доступа 
- [Losst ПРАВА ДОСТУПА К ФАЙЛАМ В LINUX](https://losst.ru/prava-dostupa-k-fajlam-v-linux)
- [Про SIUD бит](https://habr.com/ru/company/jetinfosystems/blog/506750/)

#### Основные права доступа к файлам
В Unix системах для файлов и директорий есть права на чтение/запись/выполнение
```bash
Read/Write/eXecute (r/w/x) (4/2/1) 
```

Для файлов и директорий есть понятие: Группа/Пользователь/Прочие
```bash
user/group/other (u/g/o)
```

#### Специальные права доступа (suid, suig, sticky-bit)

```bash
"suid" - если этот бит установлен, то при выполнении программы, id пользователя,
от которого она запущена заменяется на id владельца файла. 
Фактически, это позволяет обычным пользователям запускать программы от имени суперпользователя

"sgid" - этот флаг работает аналогичным образом, только разница в том, 
что пользователь считается членом группы, с которой связан файл, а не групп, 
к которым он действительно принадлежит. Если SGID флаг установлен на каталог, 
все файлы, созданные в нем, будут связаны с группой каталога, а не пользователя.
Такое поведение используется для организации общих папок;

"sticky-bit" - этот бит тоже используется для создания общих папок. 
Если он установлен, то пользователи могут только создавать, читать и выполнять файлы, 
но не могут удалять файлы, принадлежащие другим пользователям.
```

Тогда при выводе "ls -la /usr/bin/su" 
```bash
ls -la /usr/bin/su
-rwsr-xr-x 1 root root 63568 Jan 10  2019 /usr/bin/su
```

```bash
Возможные варианты прав файла/директории
Права состоят из 3 части - пользователь, группа, другие
и в каждой части по три значения,
также впереди перед тремя частями одно значение 
"-" или "l" - означает, что это ссылка на файл 
также в конце может стоять дополнительно знак "+" - 
это означает, что используются расширенные права facl (file access control list)

Возможные варианты наборов для частей:
--- - нет прав, совсем;
--x - разрешено только выполнение файла, как программы но не изменение и не чтение;
-w- - разрешена только запись и изменение файла;
-wx - разрешено изменение и выполнение, но в случае с каталогом, вы не можете посмотреть его содержимое;
r-- - права только на чтение;
r-x - только чтение и выполнение, без права на запись;
rw- - права на чтение и запись, но без выполнения;
rwx - все права;
--s - установлен SUID или SGID бит, первый отображается в поле для владельца, второй для группы;
--t - установлен sticky-bit, а значит пользователи не могут удалить этот файл.

Примеры:
"lrwxrwxrwx" - "l" - означает, что это ссылка на файл 
"-rwsrwxrwx" - "rwx" - вместо любого символа может стоять прочерк - "-", что означает, что такого права нет,
               "s" - здесь означает SUID бит
"-rwtrwxrwx" - "t" - здесь означает sticky-bit
"-rwxrwxrwx+" - знак "+" означает, что используются расширенные права facl (file access control list)
```


Пример файлов с suid битом. Те же программы su и sudo его используют.
```bash
ls -la /usr/bin/su
-rwsr-xr-x 1 root root 63568 Jan 10  2019 /usr/bin/su

ls -la /usr/bin/sudo
-rwsr-xr-x 1 root root 157192 Jan 20  2021 /usr/bin/sudo
```

#### Команды для работы с правами

##### Назначить права  - chmod
```bash
chmod
Права записываются в виде цифр
(r/w/x) (4/2/1) 
read    - 4
write   - 2
execute - 1

#Означает назначить права rwx(user) rwx(group) rwx(other) для файла FILE_NAME
chmod 777 FILE_NAME

#Как правило "стандартный" файл имеет права 644
#Означает назначить права rw(user) r(group) r(other) для файла FILE_NAME
chmod 644 FILE_NAME
```
###### Сменить пользователя/группу

```bash
# для файла MY_FILE назначить нового пользователя и новую группу
chown NEW_USER:NEW_GROUP ./MY_FILE

# для директории и файлов в ней рекурсивно назначить нового пользователя и новую группу
chown -R NEW_USER:NEW_GROUP ./MY_DIR
```

<details><summary>Пример для директории test</summary>
<p>

```bash
ls -la | grep test
drwxr-xr-x 2 root    root    4096 Aug 14 06:50 test

ls -la ./test
total 16
drwxr-xr-x 2 root    root    4096 Aug 14 06:50 .
drwxr-xr-x 8 manowar manowar 4096 Aug 14 06:50 ..
-rw-r--r-- 1 root    root       1 Aug 14 06:50 1
-rw-r--r-- 1 root    root       1 Aug 14 06:50 2

chown -R manowar:manowar ./test

ls -la | grep test
drwxr-xr-x 2 manowar manowar 4096 Aug 14 06:50 test

ls -la ./test
total 16
drwxr-xr-x 2 manowar manowar 4096 Aug 14 06:50 .
drwxr-xr-x 8 manowar manowar 4096 Aug 14 06:50 ..
-rw-r--r-- 1 manowar manowar    1 Aug 14 06:50 1
-rw-r--r-- 1 manowar manowar    1 Aug 14 06:50 2
```
</p>
</details>

### 3.2. Расширенные права facl

Можно задавать расширенный набор прав: назначать права для конкретных пользователей и групп.
```bash
setfacl - установить права
getfacl - посмотреть права
```

<details><summary>Пример использования facl</summary>
<p>

```bash

[root@server ftp]# mkdir uploads

[root@server ftp]# ls -la
итого 44
drwxr-xr-x   6 ftp  ftp  4096 Янв 26 15:51 .
drwxr-xr-x  20 root root 4096 Янв 22 14:00 ..
drwxrwxrwx+  7 ftp  ftp  4096 Янв 25 10:01 incoming
drwxr-xr-x   2 root root 4096 Янв 22 15:35 private
drwxr-xr-x   2 ftp  ftp  4096 Янв 22 13:23 pub
drwxr-xr-x   2 root root 4096 Янв 26 15:51 uploads

[root@server ftp]# setfacl -m default:user::rwx -m default:group::rx -m default:other::rx  uploads

[root@server ftp]# ls -la
итого 44
drwxr-xr-x   6 ftp  ftp  4096 Янв 26 15:51 .
drwxr-xr-x  20 root root 4096 Янв 22 14:00 ..
drwxrwxrwx+  7 ftp  ftp  4096 Янв 25 10:01 incoming
drwxr-xr-x   2 root root 4096 Янв 22 15:35 private
drwxr-xr-x   2 ftp  ftp  4096 Янв 22 13:23 pub
drwxr-xr-x+  2 root root 4096 Янв 26 15:51 uploads

[root@server ftp]# getfacl uploads
# file: uploads
# owner: root
# group: root
user::rwx
group::r-x
other::r-x
default:user::rwx
default:group::r-x
default:other::r-x

[root@server ftp]# chmod 777 uploads
[root@server ftp]# getfacl uploads
# file: uploads
# owner: root
# group: root
user::rwx
group::rwx
other::rwx
default:user::rwx
default:group::r-x
default:other::r-x

[root@server ftp]# setfacl -m default:group:advanced-users:rwx uploads
[root@server ftp]# setfacl -m default:group:adm-group:rwx uploads
[root@server ftp]# getfacl uploads
# file: uploads
# owner: root
# group: root
user::rwx
group::rwx
other::rwx
default:user::rwx
default:group::r-x
default:group:adm-group:rwx
default:group:advanced-users:rwx
default:mask::rwx
default:other::r-x

[root@server ftp]#
[root@server ftp]# cd uploads/
[root@isp8 uploads]# ls -la
итого 20
drwxrwxrwx+ 3 root  root  4096 Янв 26 16:01 .
drwxr-xr-x  6 ftp   ftp   4096 Янв 26 15:51 ..
drwxrwxr-x+ 4 fedia users 4096 Янв 26 16:01 fedia
[root@isp8 uploads]# getfacl fedia/
# file: fedia
# owner: fedia
# group: users
user::rwx
group::r-x
group:adm-group:rwx
group:advanced-users:rwx
mask::rwx
other::r-x
default:user::rwx
default:group::r-x
default:group:adm-group:rwx
default:group:advanced-users:rwx
default:mask::rwx
default:other::r-x
```
</p>
</details>

!!!warning "Важно"
			Расширенные права перекрывают набор стандартных прав.



## 4. Потоки ввода/вывода

- [Википедия - Стандартные потоки](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8)
- [Перенаправление ввода вывода в Linux](https://community.vscale.io/hc/ru/community/posts/115000171385-%D0%9F%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B2-Linux)

Стандартные потоки ввода-вывода в системах типа UNIX — потоки процесса, имеющие номер (дескриптор), зарезервированный для выполнения некоторых «стандартных» функций. Как правило, эти дескрипторы открыты уже в момент запуска исполняемого файла.

### Стандартный ввод - stdin
```bash
"stdin" - имеет дескриптор номер "0", 
предназначен для чтения команд пользователя или входных данных.
```
Можно перенаправлять данные в этот поток с помощью символа "<".

### Стандартный вывод - stdout
```bash
"stdout" - имеет дескриптор номер "1", предназначен для вывода данных, 
как правило (хотя и не обязательно) текстовых.
```
Можно перенаправлять данные из этого потока с помощью символа ">".

### Стандартный вывод ошибок - stderr
```bash
"stderr" - имеет дескриптор номер "2", предназначен для вывода 
диагностических и отладочных сообщений в текстовом виде.
```
Можно перенаправлять данные из этого потока с помощью символа "2>".

### Перенаправление потоков  " > < >> << | "

#### Примеры работы с потоками
```bash
---------------------------------------

В "stdin" можно перенаправлять данные с помощью символа "<".

#перенаправить в ввод программы test.sh содержимого файла /var/log/messages
test.sh < /var/log/messages

---------------------------------------

Из "stdout" можно перенаправлять данные с помощью символа ">".

#перенаправить вывод ошибок в /dev/null, таким образом не отображать их.
test.sh 2> /dev/null

#перенаправить stdout в /dev/null и перенаправить stderr в место, куда указывает stdout
#таким образом stdout и stderr  отпавляются в /dev/null
test.sh > /dev/null 2>&1

---------------------------------------

"|" -"pipe", "труба" - возможность перенаправления "stdout" одной программы в "stdin" другой программы

# поиск в содержимом файла /var/log/messages вхождения слова "error"
# или другими словами, что происходит с точки зрения потоков
# Вывести содержимое файла /var/log/messages и перенаправить вывод программы cat на ввод программы grep
cat /var/log/messages | grep error
--------------------------

">> <<" - перенаправление без затирания уже существующего там, а просто добваление туда
```

типы файлов: pipe,socket

## 5. Вход с систему, ограничения доступа

На примере Debian

### 5.1. Настройка ssh

#### Ограничение входа под root по ssh

С версии OpenSSH 7.0 поменялись дефолтовые параметры входа для пользователя root по ssh.

Теперь по дефолту стоит "PermitRootLogin prohibit-password".
Что означает, что удалённый вход под пользователем root с парольной и интерактивной аутентификацией теперь запрещён.

Для разрешения входа под root по ssh необходимо исправить строку в конфиге /etc/ssh/sshd_config и перезагрузить сервис.
```bash
	PermitRootLogin yes
```
#### Настройка входа по ключу под root-ом

- [LOSST Авторизация по ключу ssh](https://losst.ru/avtorizatsiya-po-klyuchu-ssh)

Для входа под root-ом по ключу ssh необходимо добавить  публичный ключ пользователя
в директорию /root/.ssh/authorized_keys 

Изначально директории /root/.ssh нет, п.э. её надо создать

```bash
cd /root
mkdir ./ssh
echo 'PUBLIC_USER_KEY' > /root/.ssh/authorized_keys
```
P.S. Чтобы пользоваться входом по ключу со стороны клиента ssh надо указать свой приватный ключ для этого соединения.

#### Настройка входа по ключу под обычной учеткой
Для входа под учеткой USERNAME по ключу ssh необходимо добавить свой публичный ключ 
в директорию пользователя /home/USERNAME/.ssh/authorized_keys.

```bash
cd /home/USERNAME
mkdir ./ssh
echo 'PUBLIC_USER_KEY' > /home/USERNAME/.ssh/authorized_keys
```
P.S. Чтобы пользоваться входом по ключу со стороны клиента ssh надо указать свой приватный ключ для этого соединения.

### 5.2. Повышение привелегий через su sudo

#### su

"su" - Позволяет заходить обыкновенному пользователю под "superuser" - пользователем root, 
введя соответственно его пароль

Алгоритм работы при использовании su:
```bash
1. Авторизуемся под своей учетной записью
2. Авторизуемся через программу su под root пользователем.
```

#### sudo 

Развернутая статья по su и sudo на [хабре](https://habr.com/ru/post/44783/)

"sudo" - Программа позволяющая более тонко настраивать права доступа по сравнению с командой "su"
Теперь администратор может указывать список разрешенных команд для каждого пользователя (или группы пользователей), файлы, доступные для редактирования, специальные переменные окружения и многое другое (все это великолепие управляется из /etc/sudoers, см. man sudoers от своего дистрибутива). При запуске sudo спрашивает у пользователя его собственный пароль, а не пароль root.

для упрощения доступа и если нет необходимости в введении доп. пароля при получении прав root
в файле /etc/sudoers
```bash
# Allow members of group sudo to execute any command
%sudo<->ALL=(ALL:ALL) NOPASSWD:ALL
```
Приемущество изначального входа под учеткой пользователя заключается в его логировании при входе под своей учеткой.

```bash
"sudo su -" vs "sudo -i"

"sudo su -" - полностью выполняется логин от имени root, наследует окружение root-а.

"su -" - команда загружает окружение именно root пользователя.

"sudo -i" -  логин эмулируется - не наследуется окружение пользователя root.

P.S. "su" и "sudo -i" - не загружают окружение пользователя root
```

#### Ограничение входа - вход только по ключу
Для разрешения входа под root по ssh необходимо исправить строку в конфиге /etc/ssh/sshd_config и перезагрузить сервис.

```bash
	PermitRootLogin no
```
P.S. как было описано выше с версии OpenSSH 7.0 дефолтовые параметры входа для пользователя root по ssh
"PermitRootLogin prohibit-password"  - При указании prohibit-password допускается только аутентификация по ключам или через GSSAPI.

При параметре "PermitRootLogin no" даже при наличии ключа для учетки root нельзя будет под ним авторизоваться.

root будет доступен только с физической или KVM консоли.

## 6. Файерволл

iptables

firewalld

## 7. Базовый набор команд

Базовый набор команд смотрите [здесь](https://icebale.readthedocs.io/en/latest/linux/commands/)

## 8. Программы для работы с репозитарием пакетов 

На примере Debian

- [LOSST APT VS APT-GET](https://losst.ru/apt-vs-apt-get-v-chem-raznitsa)
- [wiki.debian.org apt](https://wiki.debian.org/ru/Apt)
- [Базовые команды apt-get и apt-cache](https://www.kobzarev.com/linux/apt-get-and-apt-cache/)


### apt vs apt-get & apt-cache

```bash
"apt (advanced packet tools)" - менеджер управления пакетов в Debian.

"apt" - пришел на замену пакетов "apt-get" и "apt-cache" и объединил в себе функционал их обоих.
apt решает проблемы с зависимостями, получает запрошенные пакеты (из репозитория) 
и работает с "dpkg", другой утилитой, которая непосредственно устанавливает и удаляет пакеты в ОС. 

Основные команды apt:
"list" - список пакетов;
"search" - поиск пакетов по имени;
"show" - показать подробную информацию о пакете;
"update" - обновить списки доступных пакетов;
"install" - установить пакет;
"remove" - удалить пакет;
"upgrade" - установить доступные новые версии пакетов;
"full-upgrade" - полное обновление системы;
"edit-sources" - редактировать файл источников программного обеспечения.
```

```bash
"apt-get" - [deprecated] - программа для выполнения установки новых пакетов с ПО, 
удаления существующих, обновления установленных, а также для обновления всей операционной системы.

Основные команды apt-get:
"update" - обновить списки доступных пакетов;
"install" - установить пакет;
"remove" - удалить пакет;
"upgrade" - установить доступные новые версии пакетов;
```

```bash
"apt-cache" - [deprecated] - используется для поиска в кеше программных пакетов apt. 
Этот инструмент, используется для поиска пакетов, сбора информации о пакетах и поиска пакетов, 
доступных для установки.

Основные команды apt-cache:
"search" - поиск пакетов по имени;
"show" - показать подробную информацию о пакете;
```
### dpkg

```bash
"dpkg" - (Debian PacKaGe ) - арривиатуринг "LVL 70"! :)

"dpkg"- это программа используется для установки, удаления, и получения информации о .deb пакетах,
является "низкоуровневой" программ по отношению к "apt", "apt-get", "apt-cache", 
которая непосредственно устанавливает и удаляет пакеты. 

Примеры использования программы "dpkg"
"dpkg -i имя_пакета.deb" - устанока пакета с <именем имя_пакета.deb>
"dpkg -l [маска]" - вывод списка установленных пакетов.
"dpkg -r имя_пакета" - удалить пакет с имеменем <имя_пакета>
```